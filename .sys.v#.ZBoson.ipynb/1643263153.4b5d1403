{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "5462d3bf",
   "metadata": {},
   "source": [
    "# Analysis Z Boson"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "4667148d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import uproot3\n",
    "import pandas as pd \n",
    "import time \n",
    "import math \n",
    "import numpy as np \n",
    "import matplotlib.pyplot as plt \n",
    "from matplotlib.ticker import AutoMinorLocator \n",
    "\n",
    "#Local information file\n",
    "import infofile "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d34472b2",
   "metadata": {},
   "source": [
    "List with all the sampels"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 99,
   "id": "241c2b80",
   "metadata": {},
   "outputs": [],
   "source": [
    "samples = {\n",
    "    \n",
    "    #'data' : {\n",
    "        #'list' : ['data_A',\n",
    "         #        'data_B',\n",
    "          #       'data_C',\n",
    "           #      'data_D']\n",
    "    #},\n",
    "    \n",
    "    'Zsignal' : {\n",
    "        'list' : [#'Zee']\n",
    "                 #'Zmumu',\n",
    "                 'Ztautau']\n",
    "       },\n",
    "    \n",
    "   # 'diboson' : {\n",
    "    #    'list' : [#'ZqqZll', \n",
    "                  #'WqqZll',\n",
    "          #       'WpqqWmlv', \n",
    "          #       'WplvWmqq',\n",
    "           #       'WlvZqq',\n",
    "     #             'llll',\n",
    "           #       'lllv',\n",
    "            #      'llvv',\n",
    "             #     'lvvv'\n",
    "      #  ]},\n",
    "    \n",
    "    #'single_top' : {\n",
    "     #   'list' : ['single_top_tchan',\n",
    "      #            'single_antitop_tchan',\n",
    "       #           'single_top_schan',\n",
    "        #          'single_antitop_schan',\n",
    "         #         'single_top_wtchan',\n",
    "          #        'single_antitop_wtchan']\n",
    "    #},\n",
    "    \n",
    "    'WJets' : {\n",
    "        'list' : [#'Wplusenu',\n",
    "      #           'Wplusmunu',\n",
    "                 'Wplustaunu',\n",
    "        #         'Wminusenu',\n",
    "         #        'Wminusmunu',\n",
    "                 #'Wminustaunu']\n",
    "                 ]}\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 55,
   "id": "5cfb905e",
   "metadata": {},
   "outputs": [],
   "source": [
    "lumi = 10 # data_A+B+C+D\n",
    "\n",
    "fraction = 0.05 # fraction for not running the whole data (running it all make the script crash)\n",
    "\n",
    "tuple_path = \"https://atlas-opendata.web.cern.ch/atlas-opendata/samples/2020/2lep/\" "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "92d1acd9",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_data_from_files():\n",
    "\n",
    "    data = {} \n",
    "    for s in samples: \n",
    "        print('Processing '+s+' samples') \n",
    "        frames = [] \n",
    "        for val in samples[s]['list']: \n",
    "            if s == 'data': prefix = \"Data/\" # Data prefix\n",
    "            else: # MC prefix\n",
    "                prefix = \"MC/mc_\"+str(infofile.infos[val][\"DSID\"])+\".\"\n",
    "            fileString = tuple_path+prefix+val+\".2lep.root\" \n",
    "            temp = read_file(fileString,val) \n",
    "            frames.append(temp) \n",
    "        data[s] = pd.concat(frames) \n",
    "    \n",
    "    return data "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "2ba1def3",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_xsec_weight(sample):\n",
    "    info = infofile.infos[sample] \n",
    "    xsec_weight = (lumi*1000*info[\"xsec\"])/(info[\"sumw\"]*info[\"red_eff\"]) \n",
    "    return xsec_weight "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "0f1d517c",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calc_weight(xsec_weight, mcWeight, scaleFactor_PILEUP,\n",
    "                scaleFactor_ELE, scaleFactor_MUON, \n",
    "                scaleFactor_LepTRIGGER ):\n",
    "    return xsec_weight*mcWeight*scaleFactor_PILEUP*scaleFactor_ELE*scaleFactor_MUON*scaleFactor_LepTRIGGER"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40716206",
   "metadata": {},
   "source": [
    "## Definition of the cut functions"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "69081c7c",
   "metadata": {},
   "source": [
    "Check satisfied triggers E and M"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "8ffa5043",
   "metadata": {},
   "outputs": [],
   "source": [
    "def cut_trig(trige,trigm):\n",
    "    l=1\n",
    "    if trige==1 or trigm==1:\n",
    "        l=0\n",
    "    return(l != 0) "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "5e9c8342",
   "metadata": {},
   "outputs": [],
   "source": [
    "def just_two_leptons(lep_n):\n",
    "    return lep_n != 2 #throw away when the number lepton is different of 2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "681ec6bc",
   "metadata": {},
   "source": [
    "Find two good leptons"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "663d3e53",
   "metadata": {},
   "outputs": [],
   "source": [
    "def find_good_leptons(lep_pt,lep_ptcone30,lep_etcone20,lep_type,lep_eta,lep_trackd0pvunbiased,lep_tracksigd0pvunbiased,lep_z0):\n",
    "    if lep_pt[0] < 25000 : return True  #pt required to be bigger than 25GeV\n",
    "    #isolated leptons (good when <0.15)\n",
    "    if lep_ptcone30[0]/lep_pt[0] > 0.15: return True\n",
    "    if lep_ptcone30[1]/lep_pt[1] > 0.15: return True\n",
    "    if lep_etcone20[0]/lep_pt[0] > 0.15: return True\n",
    "    if lep_etcone20[1]/lep_pt[1] > 0.15: return True\n",
    "    #electron in fiducial region\n",
    "    if lep_type[0]==11 and (abs(lep_eta[0]>2.47) or abs(lep_eta[0]>1.37)) : return True\n",
    "    if lep_type[1]==11 and (abs(lep_eta[1]>2.47) or abs(lep_eta[1]>1.37)) : return True\n",
    "    if lep_type[0]==11 and lep_trackd0pvunbiased[0]/lep_tracksigd0pvunbiased[0] > 5 : return True\n",
    "    if lep_type[1]==11 and lep_trackd0pvunbiased[1]/lep_tracksigd0pvunbiased[1] > 5 : return True\n",
    "    #muon\n",
    "    if lep_type[0]==13 and abs(lep_eta[0]>2.5): return True\n",
    "    if lep_type[1]==13 and abs(lep_eta[1]>2.5): return True\n",
    "    if lep_type[0]==13 and lep_trackd0pvunbiased[0]/lep_tracksigd0pvunbiased[0] > 3 : return True\n",
    "    if lep_type[1]==13 and lep_trackd0pvunbiased[1]/lep_tracksigd0pvunbiased[1] > 3 : return True\n",
    "    #Longitudinal impact parameter\n",
    "    theta0 = 2*np.arctan(np.exp(-lep_eta[0]))\n",
    "    theta1 = 2*np.arctan(np.exp(-lep_eta[1]))\n",
    "    if abs(lep_z0[0]*np.sin(theta0))>0.5: return True\n",
    "    if abs(lep_z0[1]*np.sin(theta1))>0.5: return True\n",
    "    \n",
    "    return False"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "55530357",
   "metadata": {},
   "outputs": [],
   "source": [
    "def opposite_charge(lep_charge):\n",
    "    return lep_charge[0]*lep_charge[1] > 0 #throw away when > 0"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "a98e3a80",
   "metadata": {},
   "outputs": [],
   "source": [
    "def same_flavour(lep_type):\n",
    "    return lep_type[0]!=lep_type[1] #throw away when different flavour"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0d01d014",
   "metadata": {
    "slideshow": {
     "slide_type": "slide"
    }
   },
   "source": [
    "Invariant mass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "01d3197b",
   "metadata": {},
   "outputs": [],
   "source": [
    "def calc_inv_mass_pair(pt_1,eta_1,phi_1,E_1,pt_2,eta_2,phi_2,E_2): # pt,eta,phi,energy of 2 objects\n",
    "    px_1 = pt_1*np.cos(phi_1) # x-momentum of object 1\n",
    "    py_1 = pt_1*np.sin(phi_1) # y-momentum of object 1\n",
    "    pz_1 = pt_1*np.sinh(eta_1) # z-momentum of object 1\n",
    "    px_2 = pt_2*np.cos(phi_2) # x-momentum of object 2\n",
    "    py_2 = pt_2*np.sin(phi_2) # y-momentum of object 2\n",
    "    pz_2 = pt_2*np.sinh(eta_2) # z-momentum of object 2\n",
    "    sumpx = px_1 + px_2 # x-momentum of combined system\n",
    "    sumpy = py_1 + py_2 # y-momentum of combined system\n",
    "    sumpz = pz_1 + pz_2 # z-momentum of combined system\n",
    "    sump = np.sqrt(sumpx**2 + sumpy**2 + sumpz**2) # total momentum of combined system\n",
    "    sumE = E_1 + E_2 # total energy of combined system\n",
    "    return np.sqrt(sumE**2 - sump**2)/1000 # /1000 to go from MeV to GeV\n",
    "\n",
    "# calculate dilepton invariant mass\n",
    "def calc_mll(lep_pt,lep_eta,lep_phi,lep_E): # lepton pt,eta,phi,energy\n",
    "    return calc_inv_mass_pair(lep_pt[0],lep_eta[0],lep_phi[0],lep_E[0],lep_pt[1],lep_eta[1],lep_phi[1],lep_E[1])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "67b64481",
   "metadata": {},
   "outputs": [],
   "source": [
    "def mass_selection(invmass):\n",
    "    return abs(invmass-91.18) > 25 #we need when the difference is lesser than 25 "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "cdcc8bcb",
   "metadata": {},
   "outputs": [],
   "source": [
    "def check_jets(jet_n):\n",
    "    return jet_n != 0 #We need no jets"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4ce1f765",
   "metadata": {},
   "source": [
    "Determine the leading lepton"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "9b89b814",
   "metadata": {},
   "outputs": [],
   "source": [
    "def lead_lep(lep_pt):\n",
    "    if lep_pt[0]>lep_pt[1]:\n",
    "        return lep_pt[0]/1000\n",
    "    else:\n",
    "        return lep_pt[1]/1000"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "0ba879d6",
   "metadata": {},
   "outputs": [],
   "source": [
    "def  sublead_lep(lep_pt):\n",
    "    if lep_pt[0]>lep_pt[1]:\n",
    "        return lep_pt[1]/1000\n",
    "    else:\n",
    "        return lep_pt[0]/1000"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "84d06e22",
   "metadata": {},
   "source": [
    "### Read section "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 106,
   "id": "85f9cac4",
   "metadata": {},
   "outputs": [],
   "source": [
    "def read_file(path,sample):\n",
    "    start = time.time() # start the clock\n",
    "    print(\"\\tProcessing: \"+sample) # print which sample is being processed\n",
    "    data_all = pd.DataFrame() # define empty pandas DataFrame to hold all data for this sample\n",
    "    tree = uproot3.open(path)[\"mini\"] # open the tree called mini\n",
    "    numevents = uproot3.numentries(path, \"mini\") # number of events\n",
    "    if 'data' not in sample: xsec_weight = get_xsec_weight(sample) # get cross-section weight\n",
    "    for data in tree.iterate(['lep_charge','lep_type','lep_pt', 'lep_eta', 'lep_ptcone30',\n",
    "                              'lep_etcone20', 'lep_trackd0pvunbiased', 'lep_tracksigd0pvunbiased', 'lep_z0', 'jet_n', \n",
    "                              'trigE', 'trigM', 'lep_n', 'lep_charge', 'lep_phi', 'lep_E',\n",
    "                              'mcWeight','scaleFactor_PILEUP',\n",
    "                              'scaleFactor_ELE','scaleFactor_MUON',\n",
    "                              'scaleFactor_LepTRIGGER'\n",
    "                             ],\n",
    "                             outputtype=pd.DataFrame, # choose output type as pandas DataFrame\n",
    "                             entrystop=numevents*fraction): # process up to numevents*fraction\n",
    "\n",
    "        nIn = len(data.index) # number of events in this batch\n",
    "\n",
    "\n",
    "        # cut on triggers\n",
    "        fail = data[ np.vectorize(cut_trig)(data.trigE,data.trigM)].index\n",
    "        data.drop(fail, inplace=True)\n",
    "        \n",
    "        # cut on lepton number\n",
    "        fail = data[ np.vectorize(just_two_leptons)(data.lep_n)].index\n",
    "        data.drop(fail, inplace=True)\n",
    "        \n",
    "        # Keep just good leptons\n",
    "        fail = data[ np.vectorize(find_good_leptons)(data.lep_pt,data.lep_ptcone30,data.lep_etcone20,data.lep_type,data.lep_eta,data.lep_trackd0pvunbiased,data.lep_tracksigd0pvunbiased,data.lep_z0)].index\n",
    "        data.drop(fail, inplace=True)\n",
    "        \n",
    "        #Check SFOS\n",
    "        fail = data[ np.vectorize(opposite_charge)(data.lep_charge)].index\n",
    "        data.drop(fail, inplace=True)\n",
    "        fail = data[ np.vectorize(same_flavour)(data.lep_type)].index\n",
    "        data.drop(fail, inplace=True)\n",
    "        \n",
    "        #Check no jets\n",
    "        fail = data[ np.vectorize(check_jets)(data.jet_n)].index\n",
    "        data.drop(fail, inplace=True)\n",
    "        \n",
    "        #we're going to separate information from signal and background.\n",
    "        #The invariant mass and the leading and subleading leptons\n",
    "        #first, for signal\n",
    "        if ('ee' or'tautau' or 'mumu') in sample:\n",
    "            data['mllsignal'] = np.vectorize(calc_mll)(data.lep_pt, data.lep_eta, data.lep_phi, data.lep_E)\n",
    "            fail = data[ np.vectorize(mass_selection)(data.mllsignal)].index\n",
    "            data.drop(fail, inplace=True)\n",
    "            data['lead_ptsignal'] = np.vectorize(lead_lep)(data.lep_pt)\n",
    "            data['sublead_ptsignal'] = np.vectorize(sublead_lep)(data.lep_pt)\n",
    "            data['totalWeightsignal'] = np.vectorize(calc_weight)(xsec_weight,\n",
    "                                                            data.mcWeight,\n",
    "                                                            data.scaleFactor_PILEUP,\n",
    "                                                            data.scaleFactor_ELE,\n",
    "                                                            data.scaleFactor_MUON,\n",
    "                                                            data.scaleFactor_LepTRIGGER)\n",
    "           # roof[\"signal\"].extend({\"mll\": data.mllsignal, \"lead_lep\": data.lead_ptsignal, \"sublead_lep\": data.sublead_ptsignal, \"weight\": data.totalWeightsignal})\n",
    "        else:\n",
    "            data['mllbck'] = np.vectorize(calc_mll)(data.lep_pt, data.lep_eta, data.lep_phi, data.lep_E)\n",
    "            fail = data[ np.vectorize(mass_selection)(data.mllbck)].index\n",
    "            data.drop(fail, inplace=True)\n",
    "            data['lead_ptbck'] = np.vectorize(lead_lep)(data.lep_pt)\n",
    "            data['sublead_ptbck'] = np.vectorize(sublead_lep)(data.lep_pt)\n",
    "            data['totalWeightbck'] = np.vectorize(calc_weight)(xsec_weight,\n",
    "                                                            data.mcWeight,\n",
    "                                                            data.scaleFactor_PILEUP,\n",
    "                                                            data.scaleFactor_ELE,\n",
    "                                                            data.scaleFactor_MUON,\n",
    "                                                            data.scaleFactor_LepTRIGGER)\n",
    "            #roof[\"background\"].extend({\"mll\": data.mllbck, \"lead_lep\": data.lead_ptbck, \"sublead_lep\": data.sublead_ptbck, \"weight\": data.totalWeightbck})\n",
    "            \n",
    "                \n",
    "         #Check good mass range\n",
    "\n",
    "        \n",
    "        #Now we're going to save relevant information in root files, for being precessed by TMVA\n",
    "        print(data)\n",
    "\n",
    "        nOut = len(data.index) # number of events passing cuts in this batch\n",
    "        data_all = data_all.append(data) # append dataframe from this batch to the dataframe for the whole sample\n",
    "        elapsed = time.time() - start # time taken to process\n",
    "        print(\"\\t\\t nIn: \"+str(nIn)+\",\\t nOut: \\t\"+str(nOut)+\"\\t in \"+str(round(elapsed,1))+\"s\") # events before and after\n",
    "    \n",
    "    return data_all # return dataframe containing events passing all cuts\n",
    "\n",
    "#El siguiente paso es probar con cuales paquetes funciona y con cuales no, para luego hacer que el programa escriba sobre un archivo root, la información, la cual luego debe ser separada y entrenada, repitiendo lo hecho en hzz\n",
    "#posteriormente habría que revisar si se puede emular el sklearn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 74,
   "id": "0f348e9e",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "<TFileRecreate b'mcdata.root' at 0x7f4f6c52f280>"
      ]
     },
     "execution_count": 74,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "roof = uproot3.recreate(\"mcdata.root\")\n",
    "roof"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 75,
   "id": "b7bea6f4",
   "metadata": {},
   "outputs": [],
   "source": [
    "roof[\"signal\"] = uproot3.newtree({\"mll\": np.float32, \"lead_lep\": np.float32, \"sublead_lep\": np.float32, \"weight\": np.float32})\n",
    "roof[\"background\"] = uproot3.newtree({\"mll\": np.float32, \"lead_lep\": np.float32, \"sublead_lep\": np.float32, \"weight\": np.float32})"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 107,
   "id": "bad4237e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Processing Zsignal samples\n",
      "\tProcessing: Ztautau\n",
      "      lep_charge  lep_type                  lep_pt  \\\n",
      "entry                                                \n",
      "46       [-1, 1]  [13, 13]    [55471.06, 32427.33]   \n",
      "101      [-1, 1]  [13, 13]   [49120.66, 20830.342]   \n",
      "143      [-1, 1]  [13, 13]  [39530.848, 29220.031]   \n",
      "180      [-1, 1]  [13, 13]   [41188.13, 22783.893]   \n",
      "208      [1, -1]  [11, 11]   [29302.19, 22514.086]   \n",
      "...          ...       ...                     ...   \n",
      "8946     [1, -1]  [13, 13]  [35873.664, 33346.598]   \n",
      "8983     [-1, 1]  [13, 13]  [32683.016, 23352.102]   \n",
      "9003     [-1, 1]  [13, 13]   [45477.895, 38679.86]   \n",
      "9032     [-1, 1]  [11, 11]   [38243.38, 32371.936]   \n",
      "9074     [-1, 1]  [13, 13]  [48851.113, 22089.486]   \n",
      "\n",
      "                            lep_eta      lep_ptcone30  \\\n",
      "entry                                                   \n",
      "46         [-1.9019293, -0.8301764]        [0.0, 0.0]   \n",
      "101          [2.3270233, 1.5993329]        [0.0, 0.0]   \n",
      "143         [0.63779616, 1.2385147]        [0.0, 0.0]   \n",
      "180    [-0.90465146, 0.00093479565]        [0.0, 0.0]   \n",
      "208       [-1.9315445, 0.074300684]  [1856.6003, 0.0]   \n",
      "...                             ...               ...   \n",
      "8946       [0.20088829, 0.43720236]  [2129.2927, 0.0]   \n",
      "8983         [2.3752606, 0.8769274]        [0.0, 0.0]   \n",
      "9003         [2.1391006, 2.2050362]        [0.0, 0.0]   \n",
      "9032     [-0.33191988, -0.12361589]        [0.0, 0.0]   \n",
      "9074     [-0.8417147, -0.022890344]        [0.0, 0.0]   \n",
      "\n",
      "                   lep_etcone20         lep_trackd0pvunbiased  \\\n",
      "entry                                                           \n",
      "46     [-16.858063, -107.05438]  [-0.044853587, -0.029318003]   \n",
      "101    [-31.609943, -31.609943]   [0.016893113, 0.0030894552]   \n",
      "143     [220.71121, -505.69992]   [0.023038153, 0.0036243326]   \n",
      "180      [152.46826, -74.49109]     [0.011758289, -0.0128816]   \n",
      "208       [992.2075, 1342.0604]     [0.029749574, 0.04421633]   \n",
      "...                         ...                           ...   \n",
      "8946    [3909.5974, -429.20087]     [0.03859916, 0.020632567]   \n",
      "8983    [19.841309, -1101.4108]    [-0.02345935, -0.12625901]   \n",
      "9003     [2856.451, -221.88747]   [-0.018829755, 0.012574774]   \n",
      "9032       [1284.4509, 167.617]   [-0.005785998, 0.016207734]   \n",
      "9074       [-705.047, -705.047]     [-0.01579105, 0.03165221]   \n",
      "\n",
      "      lep_tracksigd0pvunbiased                        lep_z0  jet_n  ...  \\\n",
      "entry                                                                ...   \n",
      "46       [6.155955, 3.2585628]      [0.1015625, 0.022144318]      0  ...   \n",
      "101     [1.9483403, 0.2871022]      [0.05657959, 0.08561516]      0  ...   \n",
      "143    [2.4331563, 0.32728472]    [0.029034615, 0.042785645]      0  ...   \n",
      "180     [1.5881271, 1.1334777]   [0.0068206787, 0.014942169]      0  ...   \n",
      "208     [1.3525547, 3.9563398]   [0.045166016, -0.022583008]      0  ...   \n",
      "...                        ...                           ...    ...  ...   \n",
      "8946     [4.1842184, 2.642832]      [0.071502686, 0.0193367]      0  ...   \n",
      "8983     [1.597708, 12.460036]     [-0.1274414, -0.02318573]      0  ...   \n",
      "9003    [2.2806427, 1.2338119]      [-0.2164154, 0.07107544]      0  ...   \n",
      "9032    [0.7198641, 1.7219479]  [0.00078201294, -0.02483368]      0  ...   \n",
      "9074     [2.366556, 3.2564714]    [-0.044992924, 0.07429409]      0  ...   \n",
      "\n",
      "                        lep_E     mcWeight  scaleFactor_PILEUP  \\\n",
      "entry                                                            \n",
      "46       [189935.33, 44258.5]  1941.400024            0.750880   \n",
      "101     [254076.1, 53656.574]  1941.140015            0.402058   \n",
      "143    [47847.496, 54645.926]  1940.750000            0.738662   \n",
      "180    [59223.547, 22784.148]  1941.329956            1.214122   \n",
      "208     [103218.19, 22576.26]  1941.670044            1.745631   \n",
      "...                       ...          ...                 ...   \n",
      "8946   [36600.113, 36584.875]  1941.390015            1.251332   \n",
      "8983   [177253.19, 32921.527]  1941.280029            0.923924   \n",
      "9003    [195772.3, 177556.56]  1941.459961            1.225855   \n",
      "9032    [40369.44, 32619.586]  1941.930054            0.506784   \n",
      "9074    [67202.44, 22095.525]  1941.819946            1.262048   \n",
      "\n",
      "      scaleFactor_ELE scaleFactor_MUON scaleFactor_LepTRIGGER     mllbck  \\\n",
      "entry                                                                      \n",
      "46           1.000000         0.980254               0.961158  97.294094   \n",
      "101          1.000000         0.999716               0.959812  66.908264   \n",
      "143          1.000000         0.994541               1.009919  71.051996   \n",
      "180          1.000000         1.002160               0.934150  67.499044   \n",
      "208          0.889728         1.000000               0.831640  79.401193   \n",
      "...               ...              ...                    ...        ...   \n",
      "8946         1.000000         0.989537               0.787240  69.504732   \n",
      "8983         1.000000         0.998464               0.966761  71.474501   \n",
      "9003         1.000000         0.994211               0.997038  83.928023   \n",
      "9032         0.938462         1.000000               0.992160  70.706304   \n",
      "9074         1.000000         1.002072               0.929528  71.208716   \n",
      "\n",
      "       lead_ptbck  sublead_ptbck  totalWeightbck  \n",
      "entry                                             \n",
      "46      55.471059      32.427330        0.476955  \n",
      "101     49.120660      20.830342        0.260056  \n",
      "143     39.530848      29.220031        0.500015  \n",
      "180     41.188129      22.783893        0.766256  \n",
      "208     29.302189      22.514086        0.870920  \n",
      "...           ...            ...             ...  \n",
      "8946    35.873664      33.346598        0.657177  \n",
      "8983    32.683016      23.352102        0.601221  \n",
      "9003    45.477895      38.679859        0.819249  \n",
      "9032    38.243379      32.371936        0.318209  \n",
      "9074    48.851113      22.089486        0.792692  \n",
      "\n",
      "[229 rows x 25 columns]\n",
      "\t\t nIn: 9109,\t nOut: \t229\t in 20.1s\n",
      "Processing WJets samples\n",
      "\tProcessing: Wplustaunu\n",
      "      lep_charge  lep_type                  lep_pt  \\\n",
      "entry                                                \n",
      "38       [1, -1]  [13, 13]  [50112.418, 36858.965]   \n",
      "\n",
      "                          lep_eta           lep_ptcone30  \\\n",
      "entry                                                      \n",
      "38     [-1.5095742, -0.049400188]  [4492.296, 4090.4204]   \n",
      "\n",
      "                lep_etcone20       lep_trackd0pvunbiased  \\\n",
      "entry                                                      \n",
      "38     [275.22723, 790.2359]  [0.046520595, -0.14701812]   \n",
      "\n",
      "      lep_tracksigd0pvunbiased                        lep_z0  jet_n  ...  \\\n",
      "entry                                                                ...   \n",
      "38         [6.018993, 18.8057]  [-0.017433167, -0.102996826]      0  ...   \n",
      "\n",
      "                      lep_E      mcWeight  scaleFactor_PILEUP scaleFactor_ELE  \\\n",
      "entry                                                                           \n",
      "38     [118911.99, 36904.1]  11460.099609            1.087349             1.0   \n",
      "\n",
      "      scaleFactor_MUON scaleFactor_LepTRIGGER      mllbck  lead_ptbck  \\\n",
      "entry                                                                   \n",
      "38             0.99539               1.004813  107.822534   50.112418   \n",
      "\n",
      "       sublead_ptbck  totalWeightbck  \n",
      "entry                                 \n",
      "38         36.858965        2.136363  \n",
      "\n",
      "[1 rows x 25 columns]\n",
      "\t\t nIn: 88,\t nOut: \t1\t in 0.5s\n",
      "Time taken: 20.6s\n"
     ]
    }
   ],
   "source": [
    "start = time.time() # time at start of whole processing\n",
    "data = get_data_from_files() # process all files\n",
    "#roof.close()\n",
    "elapsed = time.time() - start # time after whole processing\n",
    "print(\"Time taken: \"+str(round(elapsed,1))+\"s\") # print total time taken to process every file"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
